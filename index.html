<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonding Optimizer: ULTIMATE</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-deep: #020617;
            --bg-panel: rgba(15, 23, 42, 0.85);
            --primary: #6366f1;
            --primary-glow: rgba(99, 102, 241, 0.4);
            --accent: #06b6d4;
            --success: #10b981;
            --danger: #f43f5e;
            --text-main: #f8fafc;
            --text-sub: #94a3b8;
            --border: rgba(148, 163, 184, 0.15);
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0; display: flex; height: 100vh;
            background-color: var(--bg-deep);
            background-image: 
                radial-gradient(circle at 50% 50%, #1e293b 0%, #020617 100%);
            color: var(--text-main); overflow: hidden;
        }

        /* UI Sidebar */
        #sidebar {
            width: 400px;
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border);
            padding: 24px; display: flex; flex-direction: column;
            box-shadow: 10px 0 40px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .title-block { margin-bottom: 24px; }
        .title-block h1 {
            font-size: 1.5rem; margin: 0; font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            letter-spacing: -0.02em;
        }
        .title-block .subtitle {
            font-size: 0.75rem; color: var(--accent); font-family: 'JetBrains Mono';
            letter-spacing: 0.1em; opacity: 0.8;
        }

        .control-group { margin-bottom: 20px; }
        .label-header {
            font-size: 0.7rem; text-transform: uppercase; color: var(--text-sub);
            font-weight: 700; letter-spacing: 0.05em; margin-bottom: 8px;
            display: flex; justify-content: space-between;
        }

        /* Buttons */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        button {
            background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            color: var(--text-sub); padding: 10px; border-radius: 6px;
            cursor: pointer; font-weight: 600; font-size: 0.85rem;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        button:hover { background: rgba(255,255,255,0.1); color: #fff; border-color: var(--text-sub); }
        button.active {
            background: var(--primary); color: #fff; border-color: var(--primary);
            box-shadow: 0 0 15px var(--primary-glow);
        }
        
        .btn-main {
            width: 100%; padding: 14px;
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            color: white; border: none; font-size: 0.9rem; letter-spacing: 0.05em;
            margin-top: 10px;
        }
        .btn-main:hover { transform: translateY(-1px); box-shadow: 0 5px 20px var(--primary-glow); }

        /* Toggles */
        .toggle-card {
            background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 8px; border: 1px solid transparent;
        }
        .toggle-card:hover { border-color: var(--border); }
        .toggle-label { font-size: 0.9rem; font-weight: 500; }

        /* Switch */
        .switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #334155; transition: .4s; border-radius: 20px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px;
            left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--success); }
        input:checked + .slider:before { transform: translateX(16px); }

        /* Stats & Logs */
        .stats-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .stat-card {
            background: rgba(15, 23, 42, 0.6); border: 1px solid var(--border);
            padding: 12px; border-radius: 8px; text-align: center;
        }
        .stat-val { font-family: 'JetBrains Mono'; font-size: 1.25rem; font-weight: 700; color: #fff; }
        .stat-lbl { font-size: 0.7rem; color: var(--text-sub); margin-top: 4px; }
        .bad { color: var(--danger); text-shadow: 0 0 10px rgba(244, 63, 94, 0.4); }
        .good { color: var(--success); text-shadow: 0 0 10px rgba(16, 185, 129, 0.4); }

        #console-log {
            flex-grow: 1; background: rgba(0,0,0,0.3); border-radius: 8px;
            padding: 10px; font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;
            color: var(--text-sub); overflow-y: auto; white-space: pre-wrap;
            border: 1px solid var(--border);
        }

        /* Canvas */
        #viewport {
            flex-grow: 1; position: relative; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        canvas { 
            box-shadow: 0 20px 80px rgba(0,0,0,0.6); 
            border-radius: 4px;
            background: rgba(15, 23, 42, 0.8);
        }

        /* Overlay Messages */
        #overlay-msg {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 10px 20px; background: var(--warning); color: #000;
            font-weight: bold; border-radius: 20px; font-size: 0.85rem;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            box-shadow: 0 10px 30px rgba(245, 158, 11, 0.3);
        }
        #overlay-msg.show { opacity: 1; }

    </style>
</head>
<body>

<div id="sidebar">
    <div class="title-block">
        <h1>Bonding Optimizer</h1>
        <div class="subtitle">ULTIMATE EDITION // VER.3.0</div>
    </div>

    <div class="control-group">
        <div class="label-header">Load Preset</div>
        <div class="btn-grid">
            <button class="active" onclick="app.loadPreset('Ariel', this)">Ariel</button>
            <button onclick="app.loadPreset('Belle', this)">Belle</button>
            <button onclick="app.loadPreset('Donald', this)">Donald</button>
        </div>
    </div>

    <div class="control-group">
        <div class="label-header">Devices</div>
        <div class="toggle-card">
            <span class="toggle-label">SQD Unit</span>
            <label class="switch"><input type="checkbox" checked onchange="app.toggleDevice(0)"><span class="slider"></span></label>
        </div>
        <div class="toggle-card">
            <span class="toggle-label">DQD Unit</span>
            <label class="switch"><input type="checkbox" checked onchange="app.toggleDevice(1)"><span class="slider"></span></label>
        </div>
    </div>

    <div class="control-group">
        <div class="label-header">Tools</div>
        <div class="toggle-card">
            <span class="toggle-label">Edit Mode (Move/Resize)</span>
            <label class="switch"><input type="checkbox" id="mode-edit" onchange="app.setMode(this.checked)"><span class="slider"></span></label>
        </div>
    </div>

    <button class="btn-main" onclick="app.optimize()">
        RUN PHYSICS SOLVER
    </button>

    <div class="control-group" style="margin-top: 20px;">
        <div class="label-header">Metrics</div>
        <div class="stats-row">
            <div class="stat-card">
                <div class="stat-val" id="val-cross">-</div>
                <div class="stat-lbl">Crossings</div>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="val-len">-</div>
                <div class="stat-lbl">Wire Length</div>
            </div>
        </div>
    </div>

    <div id="console-log">Ready.</div>
</div>

<div id="viewport">
    <canvas id="mainCanvas"></canvas>
    <div id="overlay-msg">EDIT MODE ACTIVE</div>
</div>

<script>
/**
 * MATH KERNEL
 * 幾何計算の中核ライブラリ。ベクトル演算、交差判定、形状計算。
 */
const Vec2 = {
    add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
    sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
    mul: (v, s) => ({ x: v.x * s, y: v.y * s }),
    mag: (v) => Math.hypot(v.x, v.y),
    norm: (v) => { const m = Math.hypot(v.x, v.y); return m===0 ? {x:0,y:0} : {x:v.x/m, y:v.y/m}; },
    dist: (v1, v2) => Math.hypot(v1.x - v2.x, v1.y - v2.y),
    dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
};

// 線分交差判定 (誤差許容)
function intersect(p1, p2, p3, p4) {
    const d = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
    if (Math.abs(d) < 1e-9) return false;
    const u = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / d;
    const v = ((p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x)) / d;
    // 0.01のマージンを持たせ、端点での接触は交差とみなさない
    return (u > 0.01 && u < 0.99) && (v > 0.01 && v < 0.99);
}

// パッド形状上の最近接点取得 (重要: ここが「位置ずらし」の基礎)
function getClosestPointOnPad(pt, pad) {
    // パッド中心からターゲットへのベクトル
    const dx = pt.x - pad.x;
    const dy = pt.y - pad.y;
    
    if (pad.shape === 'rect') {
        // 矩形: クランプ処理
        const hw = pad.w / 2;
        const hh = pad.h / 2;
        // 内部にいる場合も境界へ押し出す
        if (Math.abs(dx) < hw && Math.abs(dy) < hh) {
            // 近い方の辺へ
            if (hw - Math.abs(dx) < hh - Math.abs(dy)) return { x: pad.x + (dx>0?hw:-hw), y: pt.y };
            else return { x: pt.x, y: pad.y + (dy>0?hh:-hh) };
        }
        return {
            x: pad.x + Math.max(-hw, Math.min(hw, dx)),
            y: pad.y + Math.max(-hh, Math.min(hh, dy))
        };
    } else {
        // 円/楕円: 角度から外周点を計算
        const angle = Math.atan2(dy, dx);
        const a = pad.w / 2;
        const b = pad.h / 2;
        // 楕円方程式から半径Rを算出
        const r = (a*b) / Math.sqrt((b*Math.cos(angle))**2 + (a*Math.sin(angle))**2);
        return {
            x: pad.x + Math.cos(angle) * r,
            y: pad.y + Math.sin(angle) * r
        };
    }
}

/**
 * OPTIMIZER ENGINE (Ultimate)
 * 2段階最適化: 
 * 1. Simulated Annealing (どのパッドに繋ぐか)
 * 2. Force Directed Adjustment (パッド上のどこに繋ぐか)
 */
class UltimateOptimizer {
    constructor(devices, pads, padStatus) {
        this.pins = [];
        this.pads = [];
        
        // データをフラット化して管理しやすくする
        devices.forEach((d, di) => {
            if(!d.active) return;
            d.getAbsPins().forEach(p => {
                if(p.active) this.pins.push({...p, devIdx: di, id: this.pins.length});
            });
        });
        
        pads.forEach((p, i) => {
            if(padStatus[i] !== 1) { // Broken以外
                this.pads.push({...p, idx: i, status: padStatus[i]});
            }
        });
        
        // ピンごとの許容パッドリスト
        this.candidates = this.pins.map(pin => 
            this.pads.filter(pad => {
                if(pin.role === 'G') return pad.status === 0; // GNDはNormal Padのみ
                return true; // S/Dはどこでも可(RF推奨)
            })
        );
    }

    solve() {
        if(this.pins.length === 0) return { wires: [], stats: {cross:0, len:0} };

        // STEP 1: Global Assignment (SA)
        // どのピンをどのパッドIDに繋ぐかを決定
        const assignment = this.runSimulatedAnnealing();

        // STEP 2: Local Relaxation (Physics)
        // 割り当てられたパッド上で、ワイヤの着地点を微調整して交差を解く
        const optimizedWires = this.runContactPointPhysics(assignment);

        return optimizedWires;
    }

    // SA: 組み合わせ最適化
    runSimulatedAnnealing() {
        const N = this.pins.length;
        let current = new Array(N).fill(-1);

        // 初期解: 距離優先
        for(let i=0; i<N; i++) {
            let bestP = -1, minD = Infinity;
            this.candidates[i].forEach(pad => {
                let d = Vec2.dist(this.pins[i], pad);
                if(['S','D'].includes(this.pins[i].role) && pad.status===2) d -= 5000; // RF Bias
                if(d < minD) { minD = d; bestP = pad; }
            });
            current[i] = bestP;
        }

        let bestAssign = [...current];
        let minCost = this.evalAssignment(current);
        
        let temp = 100, cooling = 0.92;
        while(temp > 0.1) {
            for(let k=0; k<30; k++) { // 試行回数
                const i = Math.floor(Math.random() * N);
                const opts = this.candidates[i];
                if(opts.length > 0) {
                    const prev = current[i];
                    current[i] = opts[Math.floor(Math.random() * opts.length)];
                    
                    const cost = this.evalAssignment(current);
                    if(cost < minCost || Math.random() < Math.exp((minCost - cost)/temp)) {
                        minCost = cost;
                        bestAssign = [...current];
                    } else {
                        current[i] = prev; // Revert
                    }
                }
            }
            temp *= cooling;
        }
        return bestAssign;
    }

    // 簡易コスト評価 (中心点距離のみ)
    evalAssignment(assign) {
        let len = 0, pref = 0;
        for(let i=0; i<assign.length; i++) {
            const pad = assign[i];
            const pin = this.pins[i];
            len += Vec2.dist(pin, pad);
            if(['S','D'].includes(pin.role) && pad.status !== 2) pref += 500;
        }
        return len + pref;
    }

    // ★ PHYSICS SOLVER: 接点スライド最適化 ★
    // パッド上の着地点を「粒子」と見なし、交差を嫌う力で移動させる
    runContactPointPhysics(assignment) {
        // 初期化: まずは各パッドの「ピンに一番近い点」に着地させる
        let wires = assignment.map((pad, i) => {
            const pin = this.pins[i];
            const contact = getClosestPointOnPad(pin, pad);
            return {
                pin, pad, 
                start: {x:pin.x, y:pin.y}, 
                end: contact, // ここが可変
                fixedEnd: false
            };
        });

        const ITERATIONS = 50; // 物理演算ステップ数
        
        for(let iter=0; iter<ITERATIONS; iter++) {
            // パッドごとにグループ化
            const padGroups = {};
            wires.forEach(w => {
                if(!padGroups[w.pad.idx]) padGroups[w.pad.idx] = [];
                padGroups[w.pad.idx].push(w);
            });

            // 力の適用
            wires.forEach(w1 => {
                let force = {x:0, y:0};

                // 1. 引力: ピン方向へ引っ張られる力 (配線を短くしたい)
                const vecToPin = Vec2.sub(w1.start, w1.end);
                force = Vec2.add(force, Vec2.mul(Vec2.norm(vecToPin), 0.5));

                // 2. 斥力: 他のワイヤと交差している場合、交差を解く方向へ
                wires.forEach(w2 => {
                    if(w1 === w2) return;
                    if(intersect(w1.start, w1.end, w2.start, w2.end)) {
                        // 交差相手から離れる方向へ強い力を加える
                        // 簡易的に「相手の着地点」から離れるベクトル
                        const repel = Vec2.sub(w1.end, w2.end);
                        const dist = Vec2.mag(repel) || 0.1;
                        force = Vec2.add(force, Vec2.mul(Vec2.norm(repel), 2.0 / dist));
                    }
                });

                // 3. ファンアウト: 同じパッド内の他の接続点と離れる
                const group = padGroups[w1.pad.idx];
                if(group.length > 1) {
                    group.forEach(neighbor => {
                        if(w1 === neighbor) return;
                        const repel = Vec2.sub(w1.end, neighbor.end);
                        const dist = Vec2.mag(repel);
                        if(dist < 0.5) { // 近すぎる場合
                            force = Vec2.add(force, Vec2.mul(Vec2.norm(repel), 1.0));
                        }
                    });
                }

                // 位置更新 (仮)
                w1.end.x += force.x * 0.2;
                w1.end.y += force.y * 0.2;

                // 制約: 必ずパッドの形状上にクランプする
                w1.end = getClosestPointOnPad(w1.end, w1.pad);
            });
        }

        // 最終チェックと整形
        let crossCount = 0;
        let totalLen = 0;
        wires.forEach(w => totalLen += Vec2.dist(w.start, w.end));
        
        for(let i=0; i<wires.length; i++) {
            for(let j=i+1; j<wires.length; j++) {
                // 同じパッドへの接続同士の根本付近は無視
                if(wires[i].pad.idx === wires[j].pad.idx) continue;
                if(Vec2.dist(wires[i].start, wires[j].start) < 0.5) continue;

                if(intersect(wires[i].start, wires[i].end, wires[j].start, wires[j].end)) {
                    crossCount++;
                    wires[i].cross = true; wires[j].cross = true;
                }
            }
        }

        return { wires, stats: { cross: crossCount, len: totalLen } };
    }
}

/**
 * APPLICATION CONTROLLER
 */
const CONFIG = {
    gridSize: 12,
    presets: {
        'Ariel': { brk:[1,4,7,12,16], rf:[23,18] },
        'Belle': { brk:[0,10,11,21], rf:[23,18] },
        'Donald': { brk:[4,5,7,14,16,17,18,19,22], rf:[23] }
    }
};

class App {
    constructor() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.logEl = document.getElementById('console-log');
        
        // State
        this.devices = [
            this.createDev('SQD', 2, 4, 3.5, 3.5),
            this.createDev('DQD', 2, 5, 7.5, 7.0)
        ];
        this.pads = [];
        this.padStatus = new Array(24).fill(0);
        this.wires = [];
        this.isEditMode = false;

        // Init
        this.initPads();
        this.resize();
        this.loadPreset('Ariel', document.querySelector('button.active'));
        
        // Events
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
    }

    createDev(name, w, h, x, y) {
        return {
            name, w, h, x, y, active: true,
            getAbsPins: function() {
                const pins = [];
                for(let i=0; i<w*h; i++) {
                    const row = Math.floor(i/w), col = i%w;
                    let role = 'G';
                    if(i===0) role = 'S'; if(i===w*h-1) role = 'D';
                    pins.push({
                        x: x - (w-1)/2 + col,
                        y: y - (h-1)/2 + row,
                        role, active: true, idx: i
                    });
                }
                return pins;
            }
        };
    }

    initPads() {
        // 周囲にパッドを配置
        const range = (s, e, n) => Array.from({length:n}, (_,i) => s + (e-s)/(n-1)*i);
        const max = CONFIG.gridSize - 1;
        const coords = [
            ...range(0, max, 6).map(v => ({x:v, y:max+3, side:'top'})),
            ...range(0, max, 6).map(v => ({x:max+3, y:max-v, side:'right'})),
            ...range(0, max, 6).map(v => ({x:max-v, y:-3, side:'bottom'})),
            ...range(0, max, 6).map(v => ({x:-3, y:v, side:'left'}))
        ];
        this.pads = coords.map((c, i) => ({
            x:c.x, y:c.y, w:0.8, h:0.8, shape:'circle', lbl:i+1
        }));
    }

    log(msg) {
        this.logEl.innerText = `> ${msg}\n` + this.logEl.innerText.slice(0, 500);
    }

    loadPreset(name, btn) {
        if(btn) {
            document.querySelectorAll('.btn-grid button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }
        const p = CONFIG.presets[name];
        this.padStatus.fill(0);
        p.brk.forEach(i => this.padStatus[i] = 1); // Broken
        p.rf.forEach(i => this.padStatus[i] = 2);  // RF
        this.wires = [];
        this.updateUI({cross:'-', len:'-'});
        this.log(`Loaded preset: ${name}`);
        this.draw();
    }

    optimize() {
        this.log("Starting physics solver...");
        const opt = new UltimateOptimizer(this.devices, this.pads, this.padStatus);
        
        // Async UI update
        setTimeout(() => {
            const start = performance.now();
            const res = opt.solve();
            const time = (performance.now() - start).toFixed(1);
            
            this.wires = res.wires;
            this.updateUI(res.stats);
            this.log(`Solver finished in ${time}ms.`);
            this.log(`Crossings: ${res.stats.cross}, Length: ${res.stats.len.toFixed(1)}`);
            this.draw();
        }, 50);
    }

    updateUI(stats) {
        const cEl = document.getElementById('val-cross');
        cEl.innerText = stats.cross;
        cEl.className = 'stat-val ' + (stats.cross === 0 ? 'good' : 'bad');
        document.getElementById('val-len').innerText = typeof stats.len === 'number' ? stats.len.toFixed(1) : '-';
    }

    toggleDevice(idx) {
        this.devices[idx].active = !this.devices[idx].active;
        this.wires = []; this.draw();
    }

    setMode(edit) {
        this.isEditMode = edit;
        document.getElementById('overlay-msg').classList.toggle('show', edit);
        this.draw();
    }

    // --- DRAWING SYSTEM ---
    resize() {
        const p = this.canvas.parentElement;
        this.canvas.width = p.clientWidth;
        this.canvas.height = p.clientHeight;
        const sz = Math.min(this.canvas.width, this.canvas.height);
        this.scale = sz / (CONFIG.gridSize + 8);
        this.ox = this.canvas.width / 2;
        this.oy = this.canvas.height / 2;
        this.draw();
    }

    toScr(x, y) {
        const cx = (CONFIG.gridSize-1)/2;
        return { x: this.ox + (x - cx)*this.scale, y: this.oy - (y - cx)*this.scale };
    }
    toLog(sx, sy) {
        const cx = (CONFIG.gridSize-1)/2;
        return { x: (sx - this.ox)/this.scale + cx, y: cx - (sy - this.oy)/this.scale };
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0,0, this.canvas.width, this.canvas.height);

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 1;
        const s = -3, e = CONFIG.gridSize+2;
        for(let i=s; i<=e; i++) {
            const p1 = this.toScr(i, s), p2 = this.toScr(i, e);
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            const p3 = this.toScr(s, i), p4 = this.toScr(e, i);
            ctx.beginPath(); ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y); ctx.stroke();
        }

        // Pads
        this.pads.forEach((p, i) => {
            const sc = this.toScr(p.x, p.y);
            const w = p.w * this.scale;
            const h = p.h * this.scale;
            const st = this.padStatus[i];
            
            ctx.beginPath();
            if(p.shape==='rect') ctx.roundRect(sc.x-w/2, sc.y-h/2, w, h, 4);
            else ctx.ellipse(sc.x, sc.y, w/2, h/2, 0, 0, Math.PI*2);
            
            // Color Logic
            if(st===1) ctx.fillStyle = '#ef4444'; // Broken
            else if(st===2) ctx.fillStyle = '#3b82f6'; // RF
            else ctx.fillStyle = '#10b981'; // Normal
            
            ctx.shadowBlur = st===2 ? 15 : 0;
            ctx.shadowColor = ctx.fillStyle;
            
            ctx.fill();
            ctx.shadowBlur = 0;
            
            if(this.isEditMode) {
                ctx.strokeStyle = '#fbbf24'; ctx.lineWidth = 2; ctx.stroke();
            }

            ctx.fillStyle = '#fff'; ctx.font = 'bold 10px JetBrains Mono';
            ctx.textAlign = 'center'; ctx.textBaseline='middle';
            ctx.fillText(p.lbl, sc.x, sc.y);
        });

        // Devices
        this.devices.forEach(d => {
            if(!d.active) return;
            const sc = this.toScr(d.x, d.y);
            const w = d.w * this.scale;
            const h = d.h * this.scale;
            
            ctx.fillStyle = 'rgba(30, 41, 59, 0.8)';
            ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.roundRect(sc.x-w/2, sc.y-h/2, w, h, 8);
            ctx.fill(); ctx.stroke();
            
            // Name
            ctx.fillStyle = '#64748b'; ctx.font = 'bold 12px Inter';
            ctx.fillText(d.name, sc.x, sc.y - h/2 - 10);

            // Pins
            d.getAbsPins().forEach(p => {
                const pc = this.toScr(p.x, p.y);
                ctx.beginPath(); ctx.arc(pc.x, pc.y, 3, 0, Math.PI*2);
                ctx.fillStyle = ['S','D'].includes(p.role) ? '#60a5fa' : '#fbbf24';
                ctx.fill();
            });
        });

        // Wires (Bezier Curves for 3D effect)
        this.wires.forEach(w => {
            const p1 = this.toScr(w.start.x, w.start.y);
            const p2 = this.toScr(w.end.x, w.end.y);
            const isRF = ['S','D'].includes(w.pin.role) && w.pad.status===2;

            // Control points for Loop
            // ループの高さを表現するために、制御点を上に持ち上げる
            const mx = (p1.x + p2.x) / 2;
            const my = (p1.y + p2.y) / 2;
            const dist = Math.hypot(p1.x-p2.x, p1.y-p2.y);
            const lift = dist * 0.5; // 高さ
            
            // Shadow (Offset)
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.quadraticCurveTo(mx, my + lift*0.2, p2.x, p2.y); // Slightly curved shadow
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Main Wire
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            // 擬似3D: 手前に向かってループするような制御点
            // y座標をマイナス(画面上)に引っ張ることでループを表現
            ctx.quadraticCurveTo(mx, my - lift, p2.x, p2.y);
            
            ctx.strokeStyle = w.cross ? '#f43f5e' : (isRF ? '#60a5fa' : '#facc15');
            ctx.lineWidth = isRF ? 2.5 : 1.5;
            ctx.shadowBlur = isRF ? 10 : 0;
            ctx.shadowColor = ctx.strokeStyle;
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Contact Point
            ctx.beginPath(); ctx.arc(p2.x, p2.y, 2, 0, Math.PI*2);
            ctx.fillStyle = '#fff'; ctx.fill();
        });
    }

    setupInput() {
        let drag = null;
        this.canvas.addEventListener('mousedown', e => {
            if(!this.isEditMode) return;
            const r = this.canvas.getBoundingClientRect();
            const m = this.toLog(e.clientX-r.left, e.clientY-r.top);
            
            const hit = this.pads.findIndex(p => Vec2.dist(p, m) < Math.max(p.w, p.h)/2 + 0.5);
            if(hit !== -1) {
                drag = { idx: hit, ox: this.pads[hit].x - m.x, oy: this.pads[hit].y - m.y };
            }
        });
        window.addEventListener('mousemove', e => {
            if(drag) {
                const r = this.canvas.getBoundingClientRect();
                const m = this.toLog(e.clientX-r.left, e.clientY-r.top);
                const p = this.pads[drag.idx];
                p.x = m.x + drag.ox; p.y = m.y + drag.oy;
                this.wires = []; // Clear wires on move
                this.draw();
            }
        });
        window.addEventListener('mouseup', () => drag=null);
        
        // Right click context
        this.canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const r = this.canvas.getBoundingClientRect();
            const m = this.toLog(e.clientX-r.left, e.clientY-r.top);
            const hit = this.pads.findIndex(p => Vec2.dist(p, m) < 1);
            if(hit !== -1) {
                if(this.isEditMode) {
                    const p = this.pads[hit];
                    p.shape = p.shape==='rect'?'circle':'rect';
                } else {
                    this.padStatus[hit] = (this.padStatus[hit]+1)%3;
                    this.wires = []; // Invalidate
                }
                this.draw();
            }
        });
    }
}

const app = new App();
</script>
</body>
</html>
