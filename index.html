<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonding Optimizer QLEAP (True Perfect)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-app: #0f172a;
            --bg-panel: rgba(15, 23, 42, 0.7); 
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --accent: #6366f1; /* Indigo */
            --accent-glow: rgba(99, 102, 241, 0.5);
            --success: #10b981;
            --danger: #f43f5e;
            --warning: #f59e0b;
            --border: rgba(148, 163, 184, 0.2);
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0; display: flex; height: 100vh;
            background-color: var(--bg-app); 
            background-image: 
                linear-gradient(to right, rgba(15, 23, 42, 0.95) 380px, rgba(15, 23, 42, 0.85)),
                url('https://images.unsplash.com/photo-1635070041078-e363dbe005cb?q=80&w=2070&auto=format&fit=crop');
            background-size: cover; background-position: center;
            color: var(--text-main); overflow: hidden; user-select: none;
        }

        /* Sidebar */
        #sidebar {
            width: 380px; 
            background-color: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(16px);
            border-right: 1px solid var(--border);
            display: flex; flex-direction: column; padding: 24px;
            z-index: 20; box-shadow: 10px 0 30px rgba(0,0,0,0.4);
            overflow-y: auto;
        }

        .brand {
            font-size: 1.5rem; font-weight: 800; margin-bottom: 24px;
            background: linear-gradient(90deg, #fff, #a5b4fc);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            letter-spacing: -0.02em; display: flex; align-items: center; gap: 10px;
        }

        .btn-primary {
            width: 100%; padding: 16px;
            background: linear-gradient(135deg, var(--accent), #4f46e5);
            color: white; border: none; border-radius: 12px;
            font-size: 0.95rem; font-weight: 700; cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px var(--accent-glow);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px var(--accent-glow); }
        .btn-primary:active { transform: translateY(0); }

        .section-header {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em;
            color: var(--text-muted); margin: 24px 0 12px 0; font-weight: 700;
            border-bottom: 1px solid var(--border); padding-bottom: 8px;
        }

        /* Inputs & Toggles */
        .btn-group { display: flex; gap: 8px; margin-bottom: 10px; }
        .btn-outline {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.03);
            border: 1px solid var(--border); color: var(--text-muted);
            border-radius: 8px; cursor: pointer; font-size: 0.85rem; font-weight: 600;
            transition: all 0.2s;
        }
        .btn-outline:hover { border-color: var(--accent); color: #fff; background: rgba(99, 102, 241, 0.1); }
        .btn-outline.active { background: var(--accent); border-color: var(--accent); color: #fff; }

        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px; background: rgba(255,255,255,0.03); border-radius: 8px; margin-bottom: 8px;
            border: 1px solid transparent; transition: border-color 0.2s;
        }
        .toggle-row:hover { border-color: var(--border); }
        
        /* Stats */
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .stat-box { background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; text-align: center; }
        .stat-val { font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 700; }
        .stat-val.ok { color: var(--success); }
        .stat-val.bad { color: var(--danger); }
        .stat-lbl { font-size: 0.7rem; color: var(--text-muted); margin-top: 4px; }

        /* Canvas Area */
        #canvas-wrapper {
            flex-grow: 1; position: relative; 
            background: radial-gradient(rgba(255,255,255,0.07) 1px, transparent 1px);
            background-size: 24px 24px;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden;
        }
        canvas { 
            border-radius: 8px; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.5); 
            background: rgba(15, 23, 42, 0.6); 
        }

        /* List */
        #connection-list { margin-top: 10px; height: 150px; overflow-y: auto; font-size: 0.85rem; }
        .conn-item { 
            padding: 8px; border-bottom: 1px solid var(--border); 
            display: flex; justify-content: space-between; align-items: center;
        }
        .conn-item:hover { background: rgba(255,255,255,0.05); }
        .tag { padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold; }
        .tag-rf { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .tag-g { background: rgba(234, 179, 8, 0.2); color: #facc15; }

        /* Mode Overlay */
        #mode-overlay {
            position: absolute; top: 20px; padding: 8px 16px;
            background: var(--warning); color: #000; font-weight: bold;
            border-radius: 20px; font-size: 0.8rem; pointer-events: none;
            opacity: 0; transition: opacity 0.2s; transform: translateY(-10px);
        }
        #mode-overlay.show { opacity: 1; transform: translateY(0); }

    </style>
</head>
<body>

<div id="sidebar">
    <div class="brand">
        <span>⚡</span> Bonding Optimizer <span style="font-size:0.5em; opacity:0.6; margin-top:8px;">VER.2</span>
    </div>

    <div class="section-header">Configuration</div>
    <div class="btn-group">
        <button class="btn-outline active" onclick="app.loadPreset('Ariel', this)">Ariel</button>
        <button class="btn-outline" onclick="app.loadPreset('Belle', this)">Belle</button>
        <button class="btn-outline" onclick="app.loadPreset('Donald', this)">Donald</button>
    </div>

    <div class="toggle-row">
        <span>Active Devices</span>
        <div style="display:flex; gap:8px;">
            <label><input type="checkbox" id="chk-sqd" checked onchange="app.toggleDev(0)"> SQD</label>
            <label><input type="checkbox" id="chk-dqd" checked onchange="app.toggleDev(1)"> DQD</label>
        </div>
    </div>

    <div class="toggle-row">
        <span>Edit Pads</span>
        <input type="checkbox" id="chk-edit" onchange="app.toggleEditMode(this.checked)">
    </div>

    <div class="section-header">Action</div>
    <button id="btn-run" class="btn-primary" onclick="app.runOptimization()">
        CALCULATE OPTIMAL PATHS
    </button>

    <div class="section-header">Results</div>
    <div class="stats-grid">
        <div class="stat-box">
            <div class="stat-val" id="st-cross">-</div>
            <div class="stat-lbl">Crossings</div>
        </div>
        <div class="stat-box">
            <div class="stat-val" id="st-len">-</div>
            <div class="stat-lbl">Total Length</div>
        </div>
    </div>
    
    <div id="connection-list">
        <div style="text-align:center; padding:20px; color:var(--text-muted); opacity:0.5;">
            No calculation results yet.
        </div>
    </div>
</div>

<div id="canvas-wrapper">
    <div id="mode-overlay">EDIT MODE ACTIVE</div>
    <canvas id="mainCanvas"></canvas>
</div>

<script>
/* CORE MATH & UTILS 
   -------------------------------------------------------------
   Improving geometric accuracy for "Real Landing Point" calculation
*/

const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);

// 線分(p1-p2)と線分(p3-p4)の交差判定 (端点共有は交差とみなさない)
function checkIntersection(p1, p2, p3, p4) {
    const d = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
    if (Math.abs(d) < 1e-9) return false;
    const u = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / d;
    const v = ((p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x)) / d;
    // 0.001〜0.999 にすることで、ピン位置やパッド端点での「接触」は交差とみなさない
    return (u > 0.001 && u < 0.999) && (v > 0.001 && v < 0.999);
}

// パッド輪郭上の、指定座標(src)に最も近い点を計算する
// これが「交差回避」の肝。中心ではなく、輪郭上の座標を返す。
function getNearestPointOnPad(src, pad) {
    let nx, ny;
    const padding = 0.05; // わずかなマージン
    if (pad.shape === 'rect') {
        // クランプ処理で矩形上の最近点を求める
        const hW = pad.w / 2;
        const hH = pad.h / 2;
        // 内部にいる場合は考慮せず、常に境界または内部のクランプ点
        nx = Math.max(pad.x - hW, Math.min(pad.x + hW, src.x));
        ny = Math.max(pad.y - hH, Math.min(pad.y + hH, src.y));
    } else { 
        // 円/楕円
        const angle = Math.atan2(src.y - pad.y, src.x - pad.x);
        const a = pad.w / 2; 
        const b = pad.h / 2;
        // 楕円周上の点
        const r = (a * b) / Math.sqrt(Math.pow(b * Math.cos(angle), 2) + Math.pow(a * Math.sin(angle), 2));
        nx = pad.x + Math.cos(angle) * r;
        ny = pad.y + Math.sin(angle) * r;
    }
    return { x: nx, y: ny };
}

/* OPTIMIZER ENGINE (Improved)
   -------------------------------------------------------------
*/
class LayoutOptimizer {
    constructor(devices, pads, padStatus, deviceActive) {
        this.pins = [];
        this.pads = []; 
        this.deviceActive = deviceActive;

        // ピン情報のフラット化
        devices.forEach((d, dIdx) => {
            if (!deviceActive[dIdx]) return;
            d.getAbsPins().forEach((p) => {
                if (p.active) {
                    this.pins.push({
                        idx: this.pins.length,
                        x: p.x, y: p.y, role: p.role,
                        devIdx: dIdx, pinIdx: p.index
                    });
                }
            });
        });

        // パッド情報のフラット化
        pads.forEach((p, i) => {
            const st = padStatus[i];
            if (st !== 1) { // 1=Brokenは除外
                this.pads.push({
                    idx: this.pads.length, origIdx: i,
                    x: p.x, y: p.y, w: p.w, h: p.h, shape: p.shape,
                    status: st, lbl: p.lbl
                });
            }
        });

        // ピンごとの接続可能パッドリスト
        this.allowedPads = this.pins.map(pin => {
            return this.pads.filter(pad => {
                if (pin.role === 'G') return pad.status === 0; // Gは通常パッドのみ
                return true; // S/DはどこでもOK (RF推奨)
            }).map(p => p.idx);
        });
    }

    solve() {
        const N = this.pins.length;
        if (N === 0) return { lines: [], stats: { cross:0, len:0 } };

        let bestAssign = null;
        let bestCost = Infinity;

        // マルチスタートSA (試行回数を増やして精度向上)
        const TRIALS = 15; 
        for(let t=0; t<TRIALS; t++) {
            const res = this.runSA(N);
            if (res.cost < bestCost) {
                bestCost = res.cost;
                bestAssign = res.assign;
            }
        }

        return this.finalizeLines(bestAssign);
    }

    runSA(N) {
        // 初期解: 距離だけを考慮した貪欲法
        let currentAssign = new Array(N).fill(-1);
        
        // ランダム順で貪欲初期化
        const order = Array.from({length:N}, (_,i)=>i).sort(()=>Math.random()-0.5);
        order.forEach(i => {
            const pin = this.pins[i];
            const cands = this.allowedPads[i];
            let bestP = -1, minD = Infinity;
            cands.forEach(pi => {
                const pad = this.pads[pi];
                let d = dist(pin, pad);
                // RFピンはRFパッドを強く推奨
                if(['S','D'].includes(pin.role) && pad.status===2) d -= 5000;
                if(d < minD) { minD=d; bestP=pi; }
            });
            currentAssign[i] = bestP;
        });

        let currentCost = this.evaluate(currentAssign);
        let bestLocal = [...currentAssign];
        let bestLocalCost = currentCost;

        // Annealing
        let temp = 100.0;
        const cooling = 0.95;
        
        while(temp > 0.5) {
            for(let k=0; k < N*5; k++) {
                const cand = [...currentAssign];
                // 変形操作: 1点変更 or 2点スワップ
                if(Math.random() < 0.3 && N > 1) {
                    const i = Math.floor(Math.random()*N);
                    const j = Math.floor(Math.random()*N);
                    if(i!==j) {
                        const t = cand[i]; cand[i] = cand[j]; cand[j] = t;
                        // 妥当性チェック(簡易)
                        if(!this.allowedPads[i].includes(cand[i]) || !this.allowedPads[j].includes(cand[j])) continue;
                    }
                } else {
                    const i = Math.floor(Math.random()*N);
                    const opts = this.allowedPads[i];
                    if(opts.length > 0) cand[i] = opts[Math.floor(Math.random()*opts.length)];
                }

                const newCost = this.evaluate(cand);
                const delta = newCost - currentCost;
                
                if(delta < 0 || Math.random() < Math.exp(-delta/temp)) {
                    currentAssign = cand;
                    currentCost = newCost;
                    if(currentCost < bestLocalCost) {
                        bestLocalCost = currentCost;
                        bestLocal = [...currentAssign];
                    }
                }
            }
            temp *= cooling;
        }

        return { assign: bestLocal, cost: bestLocalCost };
    }

    // ★ 改善された評価関数 ★
    // パッドの中心ではなく「実際の着地点」を計算して交差判定を行う
    evaluate(assign) {
        let cost = 0;
        const lines = [];

        // 1. 各ピンの仮のラインを生成 (ここで NearestPoint を計算する!)
        for(let i=0; i<assign.length; i++) {
            const pid = assign[i];
            if(pid === -1) { cost += 1e9; continue; } // 未接続ペナルティ

            const pin = this.pins[i];
            const pad = this.pads[pid];
            
            // 重要: 中心距離ではなく、エッジ距離を使う
            const land = getNearestPointOnPad(pin, pad);
            const d = dist(pin, land);
            
            lines.push({ p1: pin, p2: land, role: pin.role, padSt: pad.status });
            cost += d; // 長さコスト

            // RF選好ルール
            if(['S','D'].includes(pin.role) && pad.status !== 2) cost += 1000;
        }

        // 2. 交差判定 (計算された着地点同士で判定)
        let cross = 0;
        for(let i=0; i<lines.length; i++) {
            for(let j=i+1; j<lines.length; j++) {
                // 同じパッド付近での微細な交差は無視するための閾値は checkIntersection 内で吸収
                if(checkIntersection(lines[i].p1, lines[i].p2, lines[j].p1, lines[j].p2)) {
                    cross++;
                }
            }
        }
        cost += cross * 50000; // 交差ペナルティ (非常に重く)

        return cost;
    }

    finalizeLines(assign) {
        if(!assign) return { lines:[], stats:{cross:0, len:0} };

        // 最終的なライン生成と「ファンアウト（整列）」処理
        // 同じパッドに向かう線が複数ある場合、パッド上で重ならないように少しずらす
        const padGroups = {};
        assign.forEach((pid, i) => {
            if(pid === -1) return;
            if(!padGroups[pid]) padGroups[pid] = [];
            padGroups[pid].push(this.pins[i]);
        });

        const finalLines = [];
        let totalLen = 0;

        Object.keys(padGroups).forEach(pidKey => {
            const pid = parseInt(pidKey);
            const groupPins = padGroups[pid];
            const pad = this.pads[pid];

            // 1本だけなら単純な最近点
            if (groupPins.length === 1) {
                const pin = groupPins[0];
                const land = getNearestPointOnPad(pin, pad);
                finalLines.push(this.createLineObj(pin, pad, land));
                totalLen += dist(pin, land);
            } else {
                // ★ ファンアウト処理: 入射角でソートしてパッド上に並べる
                // 簡易的に、それぞれのピンに対する「理想の着地点」を計算し、
                // それらが近すぎる場合は少し広げるなどの微調整を行うが、
                // 今回は「それぞれのピンから見た最近点」を採用するだけでも
                // 入射角が違えば着地点がずれるため、自動的にファンアウトする。
                // (前のコードは中心を目指していたので重なっていた)
                
                groupPins.forEach(pin => {
                    const land = getNearestPointOnPad(pin, pad);
                    finalLines.push(this.createLineObj(pin, pad, land));
                    totalLen += dist(pin, land);
                });
            }
        });

        // 最終統計
        let cross = 0;
        for(let i=0; i<finalLines.length; i++) {
            for(let j=i+1; j<finalLines.length; j++) {
                const l1 = finalLines[i], l2 = finalLines[j];
                // 同じパッドへの接続同士の微小交差は除外
                if (l1.padIdx === l2.padIdx) continue; 
                // ピン元の近傍も除外
                if (dist(l1.start, l2.start) < 1.0) continue;

                if(checkIntersection(l1.start, l1.end, l2.start, l2.end)) cross++;
            }
        }

        return { lines: finalLines, stats: { cross, len: totalLen } };
    }

    createLineObj(pin, pad, land) {
        return {
            start: {x:pin.x, y:pin.y},
            end: {x:land.x, y:land.y},
            role: pin.role,
            type: (['S','D'].includes(pin.role) && pad.status===2) ? 'RF' : 'Gate',
            padLbl: pad.lbl,
            padIdx: pad.idx,
            devIdx: pin.devIdx,
            pinIdx: pin.pinIdx
        };
    }
}

/* APP & UI LOGIC
   -------------------------------------------------------------
*/
const GRID_SIZE = 12;
const PRESETS = {
    'Ariel': { brk:[1,4,7,12,16], rf:[23,18] },
    'Belle': { brk:[0,10,11,21], rf:[23,18] },
    'Donald': { brk:[4,5,7,14,16,17,18,19,22], rf:[23] }
};
const LABELS = {
    top:[6,10,24,7,5,16], right:[1,14,18,19,20,21], btm:[12,2,3,4,8,22], left:[11,9,23,13,15,17]
};

class App {
    constructor() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.dpr = window.devicePixelRatio || 1;
        
        // State
        this.devices = [
            { name:'SQD', w:2, h:4, x:3.5, y:3.5, active:true },
            { name:'DQD', w:2, h:5, x:7.5, y:7.0, active:true }
        ];
        this.pads = []; 
        this.padSt = new Array(24).fill(0);
        this.lines = [];
        this.isEdit = false;
        
        // Initialize
        this.initPads();
        this.loadPreset('Ariel', document.querySelector('.btn-outline.active'));
        this.resize();
        window.addEventListener('resize', ()=>this.resize());

        // Interaction
        this.setupInteractions();
    }

    initPads() {
        this.pads = [];
        const max = GRID_SIZE-1;
        const step = max / 5;
        const newPad = (x,y,lbl) => ({x,y,w:0.8,h:0.8,shape:'circle',lbl});
        
        LABELS.top.forEach((l,i) => this.pads.push(newPad(i*step, max+3, l)));
        LABELS.right.forEach((l,i) => this.pads.push(newPad(max+3, max-i*step, l)));
        LABELS.btm.forEach((l,i) => this.pads.push(newPad((5-i)*step, -3, l)));
        LABELS.left.forEach((l,i) => this.pads.push(newPad(-3, i*step, l)));
    }

    getAbsPins(dev) {
        const pins = [];
        const cnt = dev.w * dev.h;
        for(let i=0; i<cnt; i++) {
            const col = i % dev.w; 
            const row = Math.floor(i / dev.w);
            const relX = -(dev.w-1)/2 + col;
            const relY = -(dev.h-1)/2 + row;
            // Role assignment: First=S, Last=D, others=G (Simple logic)
            let role = 'G';
            if(i===0) role = 'S';
            if(i===cnt-1) role = 'D';
            
            pins.push({
                x: dev.x + relX, y: dev.y + relY,
                role: role, active: true, index: i
            });
        }
        return pins;
    }

    // Proxy for optimization class
    getDevObjectsForOpt() {
        return this.devices.map(d => ({
            getAbsPins: () => this.getAbsPins(d)
        }));
    }

    loadPreset(name, btn) {
        if(btn) {
            document.querySelectorAll('.btn-outline').forEach(b=>b.classList.remove('active'));
            btn.classList.add('active');
        }
        const p = PRESETS[name];
        this.padSt.fill(0);
        p.brk.forEach(i => this.padSt[i] = 1);
        p.rf.forEach(i => this.padSt[i] = 2);
        this.lines = [];
        this.draw();
        this.updateStats({cross:'-', len:'-'});
    }

    runOptimization() {
        const btn = document.getElementById('btn-run');
        const originalText = btn.innerText;
        btn.innerText = "CALCULATING...";
        btn.style.opacity = 0.7;
        
        // Give UI a moment to update
        requestAnimationFrame(() => {
            setTimeout(() => {
                const devActive = this.devices.map(d => d.active);
                const opt = new LayoutOptimizer(this.getDevObjectsForOpt(), this.pads, this.padSt, devActive);
                const res = opt.solve();
                this.lines = res.lines;
                this.updateStats(res.stats);
                this.updateList();
                this.draw();
                
                btn.innerText = originalText;
                btn.style.opacity = 1;
            }, 50);
        });
    }

    toggleDev(idx) {
        this.devices[idx].active = !this.devices[idx].active;
        this.lines = []; 
        this.draw();
    }

    toggleEditMode(active) {
        this.isEdit = active;
        document.getElementById('mode-overlay').classList.toggle('show', active);
        this.draw();
    }

    updateStats(s) {
        const cEl = document.getElementById('st-cross');
        cEl.innerText = s.cross;
        cEl.className = 'stat-val ' + (s.cross===0 ? 'ok' : 'bad');
        
        const lEl = document.getElementById('st-len');
        lEl.innerText = (typeof s.len === 'number') ? s.len.toFixed(1) : '-';
        lEl.className = 'stat-val';
    }

    updateList() {
        const list = document.getElementById('connection-list');
        list.innerHTML = '';
        if(this.lines.length === 0) return;

        this.devices.forEach((d, di) => {
            if(!d.active) return;
            const devLines = this.lines.filter(l => l.devIdx === di);
            devLines.sort((a,b) => a.pinIdx - b.pinIdx);
            
            devLines.forEach(l => {
                const el = document.createElement('div');
                el.className = 'conn-item';
                const roleClass = l.type === 'RF' ? 'tag-rf' : 'tag-g';
                el.innerHTML = `
                    <div><span style="font-weight:bold">${d.name}</span> <span style="font-size:0.8em">#${l.pinIdx}</span></div>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <span class="tag ${roleClass}">${l.role}</span>
                        <span>⮕ Pad ${l.padLbl}</span>
                    </div>
                `;
                list.appendChild(el);
            });
        });
    }

    // DRAWING
    resize() {
        const w = this.canvas.parentElement.clientWidth;
        const h = this.canvas.parentElement.clientHeight;
        this.canvas.width = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width = w + 'px';
        this.canvas.style.height = h + 'px';
        this.scale = Math.min(w, h) / (GRID_SIZE + 8);
        this.offX = w/2;
        this.offY = h/2;
        this.draw();
    }

    toScr(lx, ly) {
        // Logic coords: Center is (GRID_SIZE-1)/2
        const cx = (GRID_SIZE-1)/2;
        return {
            x: this.offX + (lx - cx) * this.scale * this.dpr,
            y: this.offY - (ly - cx) * this.scale * this.dpr
        };
    }
    
    // Mouse coords to Logic coords
    toLog(sx, sy) {
        const cx = (GRID_SIZE-1)/2;
        return {
            x: (sx * this.dpr - this.offX) / (this.scale * this.dpr) + cx,
            y: cx - (sy * this.dpr - this.offY) / (this.scale * this.dpr)
        };
    }

    draw() {
        const ctx = this.ctx;
        const W = this.canvas.width, H = this.canvas.height;
        ctx.clearRect(0,0,W,H);

        // Draw Pads
        this.pads.forEach((p, i) => {
            const sc = this.toScr(p.x, p.y);
            const sw = p.w * this.scale * this.dpr;
            const sh = p.h * this.scale * this.dpr;
            const st = this.padSt[i];

            ctx.beginPath();
            if(p.shape === 'rect') ctx.roundRect(sc.x-sw/2, sc.y-sh/2, sw, sh, 4);
            else ctx.ellipse(sc.x, sc.y, sw/2, sh/2, 0, 0, Math.PI*2);
            
            ctx.fillStyle = st===1 ? '#ef4444' : (st===2 ? '#3b82f6' : '#22c55e');
            if(this.isEdit) ctx.strokeStyle = '#fbbf24';
            else ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            
            ctx.lineWidth = this.isEdit ? 3 : 1;
            ctx.fill(); ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${12*this.dpr}px "JetBrains Mono"`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(p.lbl, sc.x, sc.y);
        });

        // Draw Devices
        this.devices.forEach((d, di) => {
            if(!d.active) return;
            const sc = this.toScr(d.x, d.y);
            const sw = d.w * this.scale * this.dpr;
            const sh = d.h * this.scale * this.dpr;
            
            ctx.fillStyle = 'rgba(71, 85, 105, 0.5)';
            ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.roundRect(sc.x-sw/2, sc.y-sh/2, sw, sh, 8);
            ctx.fill(); ctx.stroke();

            // Pins
            const pins = this.getAbsPins(d);
            pins.forEach(p => {
                const pc = this.toScr(p.x, p.y);
                ctx.beginPath(); ctx.arc(pc.x, pc.y, 4*this.dpr, 0, Math.PI*2);
                ctx.fillStyle = ['S','D'].includes(p.role) ? '#60a5fa' : '#facc15';
                ctx.fill();
            });
        });

        // Draw Lines
        this.lines.forEach(l => {
            const p1 = this.toScr(l.start.x, l.start.y);
            const p2 = this.toScr(l.end.x, l.end.y);
            
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineWidth = (l.type==='RF' ? 3 : 1.5) * this.dpr;
            ctx.strokeStyle = l.type==='RF' ? '#60a5fa' : '#facc15';
            ctx.stroke();

            // Landing dot
            ctx.beginPath(); ctx.arc(p2.x, p2.y, 2.5*this.dpr, 0, Math.PI*2);
            ctx.fillStyle = '#fff'; ctx.fill();
        });
    }

    setupInteractions() {
        let drag = null;
        const getPos = (e) => {
            const r = this.canvas.getBoundingClientRect();
            return this.toLog(e.clientX - r.left, e.clientY - r.top);
        };

        this.canvas.addEventListener('mousedown', e => {
            if(!this.isEdit) return;
            const m = getPos(e);
            // Check pads
            const hit = this.pads.findIndex(p => dist(p, m) < Math.max(p.w, p.h)/2 + 0.5);
            if(hit !== -1) {
                drag = { idx: hit, offX: this.pads[hit].x - m.x, offY: this.pads[hit].y - m.y };
            }
        });

        window.addEventListener('mousemove', e => {
            if(drag) {
                const m = getPos(e);
                const p = this.pads[drag.idx];
                p.x = m.x + drag.offX;
                p.y = m.y + drag.offY;
                this.lines = []; // clear cache
                this.draw();
            }
        });

        window.addEventListener('mouseup', () => drag = null);

        // Right click to change shape/status
        this.canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const m = getPos(e);
            if(this.isEdit) {
                const hit = this.pads.findIndex(p => dist(p, m) < 1);
                if(hit !== -1) {
                    const p = this.pads[hit];
                    p.shape = p.shape === 'rect' ? 'circle' : 'rect';
                    if(p.shape==='rect' && p.w===0.8) { p.w=1.5; p.h=1.0; } // default rect size
                    if(p.shape==='circle') { p.w=0.8; p.h=0.8; }
                    this.draw();
                }
            } else {
                // Toggle status
                const hit = this.pads.findIndex(p => dist(p, m) < 1);
                if(hit !== -1) {
                    this.padSt[hit] = (this.padSt[hit] + 1) % 3;
                    this.lines = [];
                    this.draw();
                }
            }
        });
    }
}

const app = new App();
</script>
</body>
</html>
